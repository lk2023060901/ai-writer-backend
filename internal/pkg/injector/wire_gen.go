// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package injector

import (
	"context"
	"github.com/google/wire"
	"github.com/lk2023060901/ai-writer-backend/api/auth/v1"
	biz2 "github.com/lk2023060901/ai-writer-backend/internal/agent/biz"
	data5 "github.com/lk2023060901/ai-writer-backend/internal/agent/data"
	service3 "github.com/lk2023060901/ai-writer-backend/internal/agent/service"
	biz4 "github.com/lk2023060901/ai-writer-backend/internal/assistant/biz"
	data6 "github.com/lk2023060901/ai-writer-backend/internal/assistant/data"
	service5 "github.com/lk2023060901/ai-writer-backend/internal/assistant/service"
	biz5 "github.com/lk2023060901/ai-writer-backend/internal/auth/biz"
	data4 "github.com/lk2023060901/ai-writer-backend/internal/auth/data"
	service2 "github.com/lk2023060901/ai-writer-backend/internal/auth/service"
	"github.com/lk2023060901/ai-writer-backend/internal/conf"
	"github.com/lk2023060901/ai-writer-backend/internal/data"
	"github.com/lk2023060901/ai-writer-backend/internal/email/handler"
	service6 "github.com/lk2023060901/ai-writer-backend/internal/email/service"
	"github.com/lk2023060901/ai-writer-backend/internal/email/types"
	biz3 "github.com/lk2023060901/ai-writer-backend/internal/knowledge/biz"
	data2 "github.com/lk2023060901/ai-writer-backend/internal/knowledge/data"
	"github.com/lk2023060901/ai-writer-backend/internal/knowledge/embedding"
	"github.com/lk2023060901/ai-writer-backend/internal/knowledge/processor"
	"github.com/lk2023060901/ai-writer-backend/internal/knowledge/queue"
	service4 "github.com/lk2023060901/ai-writer-backend/internal/knowledge/service"
	"github.com/lk2023060901/ai-writer-backend/internal/pkg/logger"
	"github.com/lk2023060901/ai-writer-backend/internal/pkg/oauth2"
	"github.com/lk2023060901/ai-writer-backend/internal/pkg/redis"
	"github.com/lk2023060901/ai-writer-backend/internal/server"
	"github.com/lk2023060901/ai-writer-backend/internal/user/biz"
	data3 "github.com/lk2023060901/ai-writer-backend/internal/user/data"
	"github.com/lk2023060901/ai-writer-backend/internal/user/service"
	"go.uber.org/zap"
)

// Injectors from wire.go:

// InitializeApp initializes the application with Wire
func InitializeApp(config *conf.Config, log *logger.Logger) (*App, func(), error) {
	data, cleanup, err := provideData(config, log)
	if err != nil {
		return nil, nil, err
	}
	userRepo := provideUserRepo(data)
	userUseCase := biz.NewUserUseCase(userRepo)
	zapLogger := provideZapLogger(log)
	userService := service.NewUserService(userUseCase, zapLogger)
	bizUserRepo := provideAuthUserRepo(data)
	pendingAuthRepo := providePendingAuthRepo(data)
	authUseCase := provideAuthUseCase(bizUserRepo, pendingAuthRepo, config)
	authService := service2.NewAuthService(authUseCase, log)
	agentRepo := provideAgentRepo(data)
	officialAgentRepo := provideOfficialAgentRepo(data)
	agentUseCase := biz2.NewAgentUseCase(agentRepo, officialAgentRepo)
	agentService := service3.NewAgentService(agentUseCase, log)
	aiProviderConfigRepo := provideAIProviderConfigRepo(data)
	aiProviderConfigUseCase := biz3.NewAIProviderConfigUseCase(aiProviderConfigRepo)
	aiProviderService := service4.NewAIProviderService(aiProviderConfigUseCase, log)
	knowledgeBaseRepo := provideKnowledgeBaseRepo(data)
	knowledgeBaseUseCase := biz3.NewKnowledgeBaseUseCase(knowledgeBaseRepo, aiProviderConfigRepo)
	knowledgeBaseService := service4.NewKnowledgeBaseService(knowledgeBaseUseCase, aiProviderConfigUseCase, log)
	documentRepo := provideDocumentRepo(data)
	chunkRepo := provideChunkRepo(data)
	storageService := provideStorageService(data, config)
	vectorDBService := provideVectorDBService(data)
	embeddingService := provideEmbeddingService()
	documentProcessor := provideDocumentProcessor()
	documentUseCase := biz3.NewDocumentUseCase(documentRepo, chunkRepo, knowledgeBaseRepo, aiProviderConfigRepo, storageService, vectorDBService, embeddingService, documentProcessor)
	worker, err := provideDocumentWorkerWithStart(data, documentUseCase, log)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	documentService := service4.NewDocumentService(documentUseCase, worker, zapLogger)
	topicRepo := provideTopicRepo(data)
	topicUseCase := biz4.NewTopicUseCase(topicRepo)
	topicService := service5.NewTopicService(topicUseCase)
	messageRepo := provideMessageRepo(data)
	messageUseCase := biz4.NewMessageUseCase(messageRepo, topicRepo)
	messageService := service5.NewMessageService(messageUseCase)
	emailConfig := provideEmailConfig(config)
	oauth2Config := provideOAuth2Config(config)
	tokenStore, err := provideTokenStore(data)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	tokenProvider, err := provideTokenProvider(oauth2Config, tokenStore)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	emailService, err := provideEmailService(emailConfig, tokenProvider)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	emailHandler := handler.NewEmailHandler(emailService)
	client := provideRedisClient(data)
	oAuth2Handler := handler.NewOAuth2Handler(emailService, client)
	httpServer := server.NewHTTPServer(config, log, userService, authService, agentService, aiProviderService, knowledgeBaseService, documentService, topicService, messageService, emailHandler, oAuth2Handler, client)
	authServiceServer := provideGRPCAuthService(authUseCase, log)
	grpcServer := server.NewGRPCServer(config, log, authServiceServer)
	app, cleanup2 := newApp(config, log, httpServer, grpcServer, worker)
	return app, func() {
		cleanup2()
		cleanup()
	}, nil
}

// wire.go:

// ProviderSet is the Wire provider set for all dependencies
var ProviderSet = wire.NewSet(

	dataProviderSet,

	repositoryProviderSet,

	useCaseProviderSet,

	serviceProviderSet,

	httpServiceProviderSet,

	serverProviderSet,
)

// Data layer providers
var dataProviderSet = wire.NewSet(
	provideData,
	provideRedisClient,
)

// Repository providers
var repositoryProviderSet = wire.NewSet(
	provideUserRepo,
	provideAuthUserRepo,
	providePendingAuthRepo,
	provideAgentRepo,
	provideOfficialAgentRepo,
	provideAIProviderConfigRepo,
	provideKnowledgeBaseRepo,
	provideDocumentRepo,
	provideChunkRepo,
	provideTopicRepo,
	provideMessageRepo,
)

// Use case providers
var useCaseProviderSet = wire.NewSet(
	provideZapLogger, biz.NewUserUseCase, provideAuthUseCase, biz2.NewAgentUseCase, biz3.NewAIProviderConfigUseCase, biz3.NewKnowledgeBaseUseCase, biz3.NewDocumentUseCase, biz4.NewTopicUseCase, biz4.NewMessageUseCase,
)

// Service providers
var serviceProviderSet = wire.NewSet(
	provideStorageService,
	provideVectorDBService,
	provideEmbeddingService,
	provideDocumentProcessor,
	provideEmailConfig,
	provideOAuth2Config,
	provideTokenStore,
	provideTokenProvider,
)

// HTTP/gRPC service providers
var httpServiceProviderSet = wire.NewSet(service.NewUserService, service2.NewAuthService, provideGRPCAuthService, service3.NewAgentService, service4.NewAIProviderService, service4.NewKnowledgeBaseService, service4.NewDocumentService, service5.NewTopicService, service5.NewMessageService, provideEmailService, handler.NewEmailHandler, handler.NewOAuth2Handler)

// Server providers
var serverProviderSet = wire.NewSet(server.NewHTTPServer, server.NewGRPCServer, provideDocumentWorkerWithStart)

func provideAuthUseCase(
	userRepo biz5.UserRepo,
	pendingRepo biz5.PendingAuthRepo,
	config *conf.Config,
) *biz5.AuthUseCase {
	return biz5.NewAuthUseCase(
		userRepo,
		pendingRepo,
		config.Auth.JWTSecret,
		config.Auth.TOTPIssuer,
	)
}

func provideStorageService(
	d *data.Data,
	config *conf.Config,
) biz3.StorageService {
	return data2.NewMinIOStorageService(d.MinIOClient, config.MinIO.Bucket)
}

func provideVectorDBService(d *data.Data) biz3.VectorDBService {
	return data2.NewMilvusVectorDBService(d.MilvusClient)
}

func provideDocumentWorkerWithStart(
	d *data.Data,
	docUseCase *biz3.DocumentUseCase,
	log *logger.Logger,
) (*queue.Worker, error) {
	worker := queue.NewWorker(d.RedisClient, docUseCase, log.Logger, 5)
	if err := worker.Start(context.Background()); err != nil {
		return nil, err
	}
	return worker, nil
}

func provideGRPCAuthService(
	authUC *biz5.AuthUseCase,
	log *logger.Logger,
) authv1.AuthServiceServer {
	return service2.NewGRPCAuthService(authUC, log)
}

func provideData(config *conf.Config, log *logger.Logger) (*data.Data, func(), error) {
	return data.NewData(config, log.Logger)
}

func provideRedisClient(d *data.Data) *redis.Client {
	return d.RedisClient
}

func provideZapLogger(log *logger.Logger) *zap.Logger {
	return log.Logger
}

func provideUserRepo(d *data.Data) biz.UserRepo {
	return data3.NewUserRepo(d.DB)
}

func provideAuthUserRepo(d *data.Data) biz5.UserRepo {
	return data4.NewAuthUserRepo(d.DBWrapper)
}

func providePendingAuthRepo(d *data.Data) biz5.PendingAuthRepo {
	return biz5.NewRedisPendingAuthRepo(d.RedisClient)
}

func provideAgentRepo(d *data.Data) biz2.AgentRepo {
	return data5.NewAgentRepo(d.DBWrapper)
}

func provideOfficialAgentRepo(d *data.Data) biz2.OfficialAgentRepo {
	return data5.NewOfficialAgentRepo(d.DBWrapper)
}

func provideAIProviderConfigRepo(d *data.Data) biz3.AIProviderConfigRepo {
	return data2.NewAIProviderConfigRepo(d.DBWrapper)
}

func provideKnowledgeBaseRepo(d *data.Data) biz3.KnowledgeBaseRepo {
	return data2.NewKnowledgeBaseRepo(d.DBWrapper)
}

func provideDocumentRepo(d *data.Data) biz3.DocumentRepo {
	return data2.NewDocumentRepo(d.DBWrapper)
}

func provideChunkRepo(d *data.Data) biz3.ChunkRepo {
	return data2.NewChunkRepo(d.DBWrapper)
}

func provideTopicRepo(d *data.Data) biz4.TopicRepo {
	return data6.NewTopicRepo(d.DBWrapper)
}

func provideMessageRepo(d *data.Data) biz4.MessageRepo {
	return data6.NewMessageRepo(d.DBWrapper)
}

func provideEmbeddingService() biz3.EmbeddingService {
	return embedding.NewEmbeddingService()
}

func provideDocumentProcessor() biz3.DocumentProcessor {
	return processor.NewDocumentProcessor()
}

func provideEmailConfig(config *conf.Config) *types.EmailConfig {
	return &types.EmailConfig{
		SMTPHost:       config.Email.SMTPHost,
		SMTPPort:       config.Email.SMTPPort,
		FromAddr:       config.Email.FromAddr,
		FromName:       config.Email.FromName,
		OAuth2Enabled:  config.Email.OAuth2Enabled,
		MaxRetries:     config.Email.MaxRetries,
		RetryInterval:  config.Email.RetryInterval,
		ConnectTimeout: config.Email.ConnectTimeout,
		SendTimeout:    config.Email.SendTimeout,
	}
}

func provideOAuth2Config(config *conf.Config) *oauth2.Config {
	return &oauth2.Config{
		ClientID:     config.OAuth2.ClientID,
		ClientSecret: config.OAuth2.ClientSecret,
		RedirectURL:  config.OAuth2.RedirectURL,
		Scopes:       config.OAuth2.Scopes,
		AuthURL:      config.OAuth2.AuthURL,
		TokenURL:     config.OAuth2.TokenURL,
	}
}

func provideTokenStore(d *data.Data) (oauth2.TokenStore, error) {
	return oauth2.NewDatabaseTokenStore(d.DBWrapper, "gmail")
}

func provideTokenProvider(
	oauth2Config *oauth2.Config,
	tokenStore oauth2.TokenStore,
) (oauth2.TokenProvider, error) {
	return oauth2.NewGoogleTokenProvider(oauth2Config, tokenStore)
}

func provideEmailService(
	emailConfig *types.EmailConfig,
	tokenProvider oauth2.TokenProvider,
) (*service6.EmailService, error) {
	return service6.NewEmailService(emailConfig, tokenProvider)
}

func newApp(
	config *conf.Config,
	log *logger.Logger,
	httpServer *server.HTTPServer,
	grpcServer *server.GRPCServer,
	documentWorker *queue.Worker,
) (*App, func()) {

	cleanup := func() {
		if documentWorker != nil {
			documentWorker.Stop()
		}
	}

	return &App{
		Config:         config,
		Logger:         log,
		HTTPServer:     httpServer,
		GRPCServer:     grpcServer,
		DocumentWorker: documentWorker,
		cleanup:        cleanup,
	}, cleanup
}
