// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package injector

import (
	"context"
	"github.com/google/wire"
	"github.com/lk2023060901/ai-writer-backend/api/auth/v1"
	biz2 "github.com/lk2023060901/ai-writer-backend/internal/agent/biz"
	data5 "github.com/lk2023060901/ai-writer-backend/internal/agent/data"
	service3 "github.com/lk2023060901/ai-writer-backend/internal/agent/service"
	biz4 "github.com/lk2023060901/ai-writer-backend/internal/assistant/biz"
	data6 "github.com/lk2023060901/ai-writer-backend/internal/assistant/data"
	"github.com/lk2023060901/ai-writer-backend/internal/assistant/llm"
	"github.com/lk2023060901/ai-writer-backend/internal/assistant/llm/providers"
	service5 "github.com/lk2023060901/ai-writer-backend/internal/assistant/service"
	biz5 "github.com/lk2023060901/ai-writer-backend/internal/auth/biz"
	data4 "github.com/lk2023060901/ai-writer-backend/internal/auth/data"
	service2 "github.com/lk2023060901/ai-writer-backend/internal/auth/service"
	"github.com/lk2023060901/ai-writer-backend/internal/conf"
	"github.com/lk2023060901/ai-writer-backend/internal/data"
	"github.com/lk2023060901/ai-writer-backend/internal/email/handler"
	service6 "github.com/lk2023060901/ai-writer-backend/internal/email/service"
	"github.com/lk2023060901/ai-writer-backend/internal/email/types"
	biz3 "github.com/lk2023060901/ai-writer-backend/internal/knowledge/biz"
	data2 "github.com/lk2023060901/ai-writer-backend/internal/knowledge/data"
	"github.com/lk2023060901/ai-writer-backend/internal/knowledge/embedding"
	"github.com/lk2023060901/ai-writer-backend/internal/knowledge/processor"
	"github.com/lk2023060901/ai-writer-backend/internal/knowledge/queue"
	service4 "github.com/lk2023060901/ai-writer-backend/internal/knowledge/service"
	"github.com/lk2023060901/ai-writer-backend/internal/pkg/logger"
	"github.com/lk2023060901/ai-writer-backend/internal/pkg/mineru"
	"github.com/lk2023060901/ai-writer-backend/internal/pkg/oauth2"
	"github.com/lk2023060901/ai-writer-backend/internal/pkg/redis"
	"github.com/lk2023060901/ai-writer-backend/internal/pkg/sse"
	"github.com/lk2023060901/ai-writer-backend/internal/pkg/workerpool"
	"github.com/lk2023060901/ai-writer-backend/internal/server"
	"github.com/lk2023060901/ai-writer-backend/internal/user/biz"
	data3 "github.com/lk2023060901/ai-writer-backend/internal/user/data"
	"github.com/lk2023060901/ai-writer-backend/internal/user/service"
	"go.uber.org/zap"
	"time"
)

// Injectors from wire.go:

// InitializeApp initializes the application with Wire
func InitializeApp(config *conf.Config, log *logger.Logger) (*App, func(), error) {
	data, cleanup, err := provideData(config, log)
	if err != nil {
		return nil, nil, err
	}
	userRepo := provideUserRepo(data)
	userUseCase := biz.NewUserUseCase(userRepo)
	zapLogger := provideZapLogger(log)
	userService := service.NewUserService(userUseCase, zapLogger)
	bizUserRepo := provideAuthUserRepo(data)
	pendingAuthRepo := providePendingAuthRepo(data)
	authUseCase := provideAuthUseCase(bizUserRepo, pendingAuthRepo, config)
	authService := service2.NewAuthService(authUseCase, log)
	agentRepo := provideAgentRepo(data)
	officialAgentRepo := provideOfficialAgentRepo(data)
	agentUseCase := biz2.NewAgentUseCase(agentRepo, officialAgentRepo)
	agentService := service3.NewAgentService(agentUseCase, log)
	aiProviderRepo := provideAIProviderRepo(data)
	aiProviderUseCase := biz3.NewAIProviderUseCase(aiProviderRepo)
	aiModelRepo := provideAIModelRepo(data)
	aiModelUseCase := biz3.NewAIModelUseCase(aiModelRepo)
	aiProviderService := service4.NewAIProviderService(aiProviderUseCase, aiModelUseCase, log)
	modelSyncLogRepo := provideModelSyncLogRepo(data)
	modelSyncUseCase := biz3.NewModelSyncUseCase(aiProviderRepo, aiModelRepo, modelSyncLogRepo)
	aiModelService := service4.NewAIModelService(aiModelUseCase, modelSyncUseCase, zapLogger)
	documentProviderRepo := provideDocumentProviderRepo(data)
	documentProviderUseCase := biz3.NewDocumentProviderUseCase(documentProviderRepo)
	documentProviderService := service4.NewDocumentProviderService(documentProviderUseCase, log)
	knowledgeBaseRepo := provideKnowledgeBaseRepo(data)
	knowledgeBaseUseCase := biz3.NewKnowledgeBaseUseCase(knowledgeBaseRepo, aiModelRepo)
	knowledgeBaseService := service4.NewKnowledgeBaseService(knowledgeBaseUseCase, aiProviderUseCase, log)
	documentRepo := provideDocumentRepo(data)
	chunkRepo := provideChunkRepo(data)
	fileStorageRepo := provideFileStorageRepo(data)
	storageService := provideStorageService(data, config)
	vectorDBService := provideVectorDBService(data)
	embeddingService := provideEmbeddingService()
	client, err := provideMinerUClient(config, log)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	documentProcessor := provideDocumentProcessor(client, log)
	documentUseCase := provideDocumentUseCase(documentRepo, chunkRepo, knowledgeBaseRepo, aiModelRepo, aiProviderRepo, fileStorageRepo, storageService, vectorDBService, embeddingService, documentProcessor, log)
	hub := provideSSEHub()
	worker, err := provideDocumentWorkerWithStart(data, documentUseCase, hub, log)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	pool, err := provideUploadWorkerPool(config, log)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	documentService := service4.NewDocumentService(documentUseCase, worker, pool, hub, zapLogger)
	assistantRepo := provideAssistantRepo(data)
	topicRepo := provideTopicRepo(data)
	assistantUseCase := biz4.NewAssistantUseCase(assistantRepo, topicRepo)
	topicUseCase := biz4.NewTopicUseCase(topicRepo)
	messageRepo := provideMessageRepo(data)
	messageUseCase := biz4.NewMessageUseCase(messageRepo, topicRepo)
	providerFactory := provideProviderFactory(aiProviderUseCase, zapLogger)
	multiProviderOrchestrator := provideOrchestrator(providerFactory, documentUseCase, zapLogger)
	assistantService := service5.NewAssistantService(assistantUseCase, topicUseCase, messageUseCase, hub, multiProviderOrchestrator)
	topicService := service5.NewTopicService(topicUseCase)
	messageService := service5.NewMessageService(messageUseCase)
	favoriteRepo := provideFavoriteRepo(data)
	favoriteUseCase := biz4.NewFavoriteUseCase(favoriteRepo)
	favoriteService := service5.NewFavoriteService(favoriteUseCase)
	emailConfig := provideEmailConfig(config)
	oauth2Config := provideOAuth2Config(config)
	tokenStore, err := provideTokenStore(data)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	tokenProvider, err := provideTokenProvider(oauth2Config, tokenStore)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	emailService, err := provideEmailService(emailConfig, tokenProvider)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	emailHandler := handler.NewEmailHandler(emailService)
	redisClient := provideRedisClient(data)
	oAuth2Handler := handler.NewOAuth2Handler(emailService, redisClient)
	httpServer := server.NewHTTPServer(config, log, userService, authService, agentService, aiProviderService, aiModelService, documentProviderService, knowledgeBaseService, documentService, assistantService, topicService, messageService, favoriteService, emailHandler, oAuth2Handler, redisClient)
	authServiceServer := provideGRPCAuthService(authUseCase, log)
	grpcServer := server.NewGRPCServer(config, log, authServiceServer)
	app, cleanup2 := newApp(config, log, httpServer, grpcServer, worker, pool)
	return app, func() {
		cleanup2()
		cleanup()
	}, nil
}

// wire.go:

// ProviderSet is the Wire provider set for all dependencies
var ProviderSet = wire.NewSet(

	dataProviderSet,

	repositoryProviderSet,

	useCaseProviderSet,

	serviceProviderSet,

	httpServiceProviderSet,

	serverProviderSet,
)

// Data layer providers
var dataProviderSet = wire.NewSet(
	provideData,
	provideRedisClient,
)

// Repository providers
var repositoryProviderSet = wire.NewSet(
	provideUserRepo,
	provideAuthUserRepo,
	providePendingAuthRepo,
	provideAgentRepo,
	provideOfficialAgentRepo,
	provideAIProviderRepo,
	provideAIModelRepo,
	provideModelSyncLogRepo,
	provideDocumentProviderRepo,
	provideKnowledgeBaseRepo,
	provideDocumentRepo,
	provideChunkRepo,
	provideFileStorageRepo,
	provideAssistantRepo,
	provideTopicRepo,
	provideMessageRepo,
	provideFavoriteRepo,
)

// Use case providers
var useCaseProviderSet = wire.NewSet(
	provideZapLogger, biz.NewUserUseCase, provideAuthUseCase, biz2.NewAgentUseCase, biz3.NewAIProviderUseCase, biz3.NewAIModelUseCase, biz3.NewModelSyncUseCase, biz3.NewDocumentProviderUseCase, biz3.NewKnowledgeBaseUseCase, provideDocumentUseCase, biz4.NewAssistantUseCase, biz4.NewTopicUseCase, biz4.NewMessageUseCase, biz4.NewFavoriteUseCase,
)

// Service providers
var serviceProviderSet = wire.NewSet(
	provideStorageService,
	provideVectorDBService,
	provideEmbeddingService,
	provideMinerUClient,
	provideDocumentProcessor,
	provideEmailConfig,
	provideOAuth2Config,
	provideTokenStore,
	provideTokenProvider,
	provideSSEHub,
	provideProviderFactory,
	provideOrchestrator,
	provideUploadWorkerPool,
)

// HTTP/gRPC service providers
var httpServiceProviderSet = wire.NewSet(service.NewUserService, service2.NewAuthService, provideGRPCAuthService, service3.NewAgentService, service4.NewAIProviderService, service4.NewAIModelService, service4.NewDocumentProviderService, service4.NewKnowledgeBaseService, service4.NewDocumentService, service5.NewAssistantService, service5.NewTopicService, service5.NewMessageService, service5.NewFavoriteService, provideEmailService, handler.NewEmailHandler, handler.NewOAuth2Handler)

// Server providers
var serverProviderSet = wire.NewSet(server.NewHTTPServer, server.NewGRPCServer, provideDocumentWorkerWithStart)

func provideAuthUseCase(
	userRepo biz5.UserRepo,
	pendingRepo biz5.PendingAuthRepo,
	config *conf.Config,
) *biz5.AuthUseCase {
	return biz5.NewAuthUseCase(
		userRepo,
		pendingRepo,
		config.Auth.JWTSecret,
		config.Auth.TOTPIssuer,
	)
}

func provideStorageService(
	d *data.Data,
	config *conf.Config,
) biz3.StorageService {
	return data2.NewMinIOStorageService(d.MinIOClient, config.MinIO.Bucket)
}

func provideVectorDBService(d *data.Data) biz3.VectorDBService {
	return data2.NewMilvusVectorDBService(d.MilvusClient)
}

func provideSSEHub() *sse.Hub {
	return sse.NewHub()
}

func provideDocumentWorkerWithStart(
	d *data.Data,
	docUseCase *biz3.DocumentUseCase,
	sseHub *sse.Hub,
	log *logger.Logger,
) (*queue.Worker, error) {
	worker := queue.NewWorker(d.RedisClient, docUseCase, sseHub, log.Logger, 5)
	if err := worker.Start(context.Background()); err != nil {
		return nil, err
	}
	return worker, nil
}

func provideGRPCAuthService(
	authUC *biz5.AuthUseCase,
	log *logger.Logger,
) authv1.AuthServiceServer {
	return service2.NewGRPCAuthService(authUC, log)
}

func provideData(config *conf.Config, log *logger.Logger) (*data.Data, func(), error) {
	return data.NewData(config, log.Logger)
}

func provideRedisClient(d *data.Data) *redis.Client {
	return d.RedisClient
}

func provideZapLogger(log *logger.Logger) *zap.Logger {
	return log.Logger
}

func provideDocumentUseCase(
	documentRepo biz3.DocumentRepo,
	chunkRepo biz3.ChunkRepo,
	kbRepo biz3.KnowledgeBaseRepo,
	aiModelRepo biz3.AIModelRepo,
	aiProviderRepo biz3.AIProviderRepo,
	fileStorageRepo biz3.FileStorageRepo,
	storage biz3.StorageService,
	vectorDB biz3.VectorDBService,
	embedder biz3.EmbeddingService,
	processor biz3.DocumentProcessor,
	log *logger.Logger,
) *biz3.DocumentUseCase {
	return biz3.NewDocumentUseCase(
		documentRepo,
		chunkRepo,
		kbRepo,
		aiModelRepo,
		aiProviderRepo,
		fileStorageRepo,
		storage,
		vectorDB,
		embedder,
		processor,
		log,
	)
}

func provideUserRepo(d *data.Data) biz.UserRepo {
	return data3.NewUserRepo(d.DB)
}

func provideAuthUserRepo(d *data.Data) biz5.UserRepo {
	return data4.NewAuthUserRepo(d.DBWrapper)
}

func providePendingAuthRepo(d *data.Data) biz5.PendingAuthRepo {
	return biz5.NewRedisPendingAuthRepo(d.RedisClient)
}

func provideAgentRepo(d *data.Data) biz2.AgentRepo {
	return data5.NewAgentRepo(d.DBWrapper)
}

func provideOfficialAgentRepo(d *data.Data) biz2.OfficialAgentRepo {
	return data5.NewOfficialAgentRepo(d.DBWrapper)
}

func provideAIProviderRepo(d *data.Data) biz3.AIProviderRepo {
	return data2.NewAIProviderRepo(d.DBWrapper)
}

func provideAIModelRepo(d *data.Data) biz3.AIModelRepo {
	return data2.NewAIModelRepo(d.DBWrapper)
}

func provideDocumentProviderRepo(d *data.Data) biz3.DocumentProviderRepo {
	return data2.NewDocumentProviderRepo(d.DBWrapper)
}

func provideKnowledgeBaseRepo(d *data.Data) biz3.KnowledgeBaseRepo {
	return data2.NewKnowledgeBaseRepo(d.DBWrapper)
}

func provideDocumentRepo(d *data.Data) biz3.DocumentRepo {
	return data2.NewDocumentRepo(d.DBWrapper)
}

func provideChunkRepo(d *data.Data) biz3.ChunkRepo {
	return data2.NewChunkRepo(d.DBWrapper)
}

func provideFileStorageRepo(d *data.Data) biz3.FileStorageRepo {
	kbrepo := data2.NewFileStorageRepository(d.DBWrapper)
	return data2.NewFileStorageRepo(kbrepo)
}

func provideAssistantRepo(d *data.Data) biz4.AssistantRepo {
	return data6.NewAssistantRepo(d.DB)
}

func provideTopicRepo(d *data.Data) biz4.TopicRepo {
	return data6.NewTopicRepo(d.DBWrapper)
}

func provideMessageRepo(d *data.Data) biz4.MessageRepo {
	return data6.NewMessageRepo(d.DBWrapper)
}

func provideFavoriteRepo(d *data.Data) biz4.FavoriteRepo {
	return data6.NewFavoriteRepo(d.DBWrapper)
}

func provideModelSyncLogRepo(d *data.Data) biz3.ModelSyncLogRepo {
	return data2.NewModelSyncLogRepo(d.DBWrapper)
}

func provideEmbeddingService() biz3.EmbeddingService {
	return embedding.NewEmbeddingService()
}

func provideMinerUClient(config *conf.Config, log *logger.Logger) (*mineru.Client, error) {
	cfg := &mineru.Config{
		BaseURL:         config.MinerU.BaseURL,
		APIKey:          config.MinerU.APIKey,
		Timeout:         config.MinerU.Timeout,
		MaxRetries:      config.MinerU.MaxRetries,
		DefaultLanguage: config.MinerU.DefaultLanguage,
		EnableFormula:   config.MinerU.EnableFormula,
		EnableTable:     config.MinerU.EnableTable,
		ModelVersion:    config.MinerU.ModelVersion,
	}
	return mineru.New(cfg, log)
}

func provideDocumentProcessor(client *mineru.Client, log *logger.Logger) biz3.DocumentProcessor {
	return processor.NewMinerUProcessor(client, log)
}

func provideEmailConfig(config *conf.Config) *types.EmailConfig {
	return &types.EmailConfig{
		SMTPHost:       config.Email.SMTPHost,
		SMTPPort:       config.Email.SMTPPort,
		FromAddr:       config.Email.FromAddr,
		FromName:       config.Email.FromName,
		OAuth2Enabled:  config.Email.OAuth2Enabled,
		MaxRetries:     config.Email.MaxRetries,
		RetryInterval:  config.Email.RetryInterval,
		ConnectTimeout: config.Email.ConnectTimeout,
		SendTimeout:    config.Email.SendTimeout,
	}
}

func provideOAuth2Config(config *conf.Config) *oauth2.Config {
	return &oauth2.Config{
		ClientID:     config.OAuth2.ClientID,
		ClientSecret: config.OAuth2.ClientSecret,
		RedirectURL:  config.OAuth2.RedirectURL,
		Scopes:       config.OAuth2.Scopes,
		AuthURL:      config.OAuth2.AuthURL,
		TokenURL:     config.OAuth2.TokenURL,
	}
}

func provideTokenStore(d *data.Data) (oauth2.TokenStore, error) {
	return oauth2.NewDatabaseTokenStore(d.DBWrapper, "gmail")
}

func provideTokenProvider(
	oauth2Config *oauth2.Config,
	tokenStore oauth2.TokenStore,
) (oauth2.TokenProvider, error) {
	return oauth2.NewGoogleTokenProvider(oauth2Config, tokenStore)
}

func provideEmailService(
	emailConfig *types.EmailConfig,
	tokenProvider oauth2.TokenProvider,
) (*service6.EmailService, error) {
	return service6.NewEmailService(emailConfig, tokenProvider)
}

// provideProviderFactory 提供 AI Provider 工厂
func provideProviderFactory(
	aiProviderUseCase *biz3.AIProviderUseCase,
	zapLogger *zap.Logger,
) llm.ProviderFactory {
	return providers.NewDatabaseProviderFactory(aiProviderUseCase, zapLogger)
}

// provideOrchestrator 提供多服务商编排器
func provideOrchestrator(
	providerFactory llm.ProviderFactory,
	docUseCase *biz3.DocumentUseCase,
	zapLogger *zap.Logger,
) llm.MultiProviderOrchestrator {

	knowledgeSearcher := llm.NewKnowledgeAdapter(docUseCase)

	return llm.NewOrchestrator(
		providerFactory,
		nil,
		nil,
		nil,
		nil,
		nil,
		knowledgeSearcher,
		zapLogger,
	)
}

// provideUploadWorkerPool 提供上传文件 Worker Pool
func provideUploadWorkerPool(
	config *conf.Config,
	log *logger.Logger,
) (*workerpool.Pool, error) {

	poolConfig := &workerpool.Config{
		InitialWorkers: 2,
		QueueSize:      1000,
		EnablePriority: false,
		AutoScaling: &workerpool.AutoScalingConfig{
			Enable:                    true,
			MinWorkers:                2,
			MaxWorkers:                2,
			ScaleUpQueueThreshold:     800,
			ScaleUpUtilizationRatio:   0.8,
			ScaleDownUtilizationRatio: 0.2,
			ScaleUpStep:               1,
			ScaleDownStep:             1,
			CooldownPeriod:            30 * time.Second,
			EnablePredictive:          true,
		},
	}

	return workerpool.New(poolConfig, log.Logger)
}

func newApp(
	config *conf.Config,
	log *logger.Logger,
	httpServer *server.HTTPServer,
	grpcServer *server.GRPCServer,
	documentWorker *queue.Worker,
	uploadPool *workerpool.Pool,
) (*App, func()) {

	cleanup := func() {
		if documentWorker != nil {
			documentWorker.Stop()
		}
		if uploadPool != nil {
			uploadPool.Shutdown()
		}
	}

	return &App{
		Config:         config,
		Logger:         log,
		HTTPServer:     httpServer,
		GRPCServer:     grpcServer,
		DocumentWorker: documentWorker,
		cleanup:        cleanup,
	}, cleanup
}
